---
// Starfield Hero Component with Three.js
---

<section id="hero" class="starfield-hero relative min-h-screen flex items-center justify-center overflow-hidden">
  <!-- Three.js Canvas -->
  <canvas id="starfield-canvas" class="absolute inset-0 w-full h-full"></canvas>
  
  <!-- Hero Content Overlay -->
  <div class="hero-content relative z-10 text-center px-4 max-w-5xl mx-auto">
    <h1 class="hero-title text-5xl sm:text-6xl md:text-7xl lg:text-8xl font-bold mb-6">
      <span class="hero-name">Shrey Khosla</span>
    </h1>
    <p class="hero-subtitle text-xl sm:text-2xl md:text-3xl text-text-secondary mb-8">
      Senior Software Engineer
    </p>
    <p class="hero-description text-base sm:text-lg md:text-xl text-text-muted max-w-2xl mx-auto mb-12 opacity-0 leading-relaxed">
      7+ years building products from 0→1 to N→N+1 across startups and enterprise
    </p>
    <div class="hero-ctas flex flex-col sm:flex-row gap-6 justify-center items-center opacity-0 mt-4">
      <a href="#experience" class="cta-primary px-12 py-5 glassmorphism glow-border rounded-lg hover:scale-105 transition-all duration-300 font-semibold text-text-primary text-lg min-w-[200px] text-center">
        View Work
      </a>
      <a href="#contact" class="cta-secondary px-12 py-5 bg-accent-blue rounded-lg hover:bg-accent-cyan transition-all duration-300 font-semibold shadow-lg shadow-accent-blue/50 text-lg min-w-[200px] text-center" style="color: oklch(1.0 0 0);">
        Get in Touch
      </a>
    </div>
  </div>
  
  <!-- Scroll Indicator -->
  <div class="scroll-indicator absolute bottom-8 left-1/2 transform -translate-x-1/2 z-10">
    <div class="scroll-arrow animate-bounce">
      <svg class="w-6 h-6 text-accent-blue" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
      </svg>
    </div>
  </div>
</section>

<script>
  import * as THREE from 'three';
  
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  
  // Initialize Three.js scene
  function initStarfield() {
    const canvas = document.getElementById('starfield-canvas') as HTMLCanvasElement;
    if (!canvas) return;
    
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;
    
    const renderer = new THREE.WebGLRenderer({
      canvas,
      alpha: true,
      antialias: false, // Disable for performance
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for performance
    
    // Create starfield
    const starCount = prefersReducedMotion ? 1000 : 3000; // Fewer stars in reduced motion mode
    const starGeometry = new THREE.BufferGeometry();
    const starPositions = new Float32Array(starCount * 3);
    const starSizes = new Float32Array(starCount);
    const starColors = new Float32Array(starCount * 3);
    
    // Color palette (blue/cyan/purple theme)
    const colors = [
      new THREE.Color(0.65, 0.75, 1.0),   // Light blue
      new THREE.Color(0.45, 0.65, 1.0),   // Med blue
      new THREE.Color(0.55, 0.45, 0.95),  // Purple
      new THREE.Color(0.85, 0.95, 1.0),   // Cyan
    ];
    
    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;
      
      // Position - distributed in a sphere around the camera
      const radius = 10 + Math.random() * 40;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      
      starPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);      starPositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
      starPositions[i3 + 2] = radius * Math.cos(phi) - 20;
      
      // Size - varied
      starSizes[i] = Math.random() * 2 + 0.5;
      
      // Color - from palette
      const color = colors[Math.floor(Math.random() * colors.length)];
      starColors[i3] = color.r;
      starColors[i3 + 1] = color.g;
      starColors[i3 + 2] = color.b;
    }
    
    starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
    starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
    
    // Star material with custom shader for glow effect
    const starMaterial = new THREE.PointsMaterial({
      size: 0.1,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true,
      blending: THREE.AdditiveBlending,
    });
    
    const stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);
    
    // Mouse parallax
    let mouseX = 0;
    let mouseY = 0;
    let targetRotationX = 0;
    let targetRotationY = 0;
    
    if (!prefersReducedMotion) {
      window.addEventListener('mousemove', (event) => {
        mouseX = (event.clientX / window.innerWidth) * 2 - 1;
        mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
        targetRotationX = mouseY * 0.1;
        targetRotationY = mouseX * 0.1;
      });
    }
    
    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Animation loop
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      
      if (!prefersReducedMotion) {
        time += 0.001;
        
        // Gentle rotation
        stars.rotation.y += 0.0002;
        stars.rotation.x += 0.0001;
        
        // Smooth parallax
        stars.rotation.y += (targetRotationY - stars.rotation.y) * 0.05;
        stars.rotation.x += (targetRotationX - stars.rotation.x) * 0.05;
        
        // Gentle pulse effect on sizes
        const positions = starGeometry.attributes.position.array as Float32Array;
        for (let i = 0; i < starCount; i++) {
          const i3 = i * 3;
          positions[i3 + 2] += Math.sin(time + i) * 0.01;
        }
        starGeometry.attributes.position.needsUpdate = true;
      }
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Cleanup on page unload
    return () => {
      renderer.dispose();
      starGeometry.dispose();
      starMaterial.dispose();
    };
  }
  
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initStarfield);
  } else {
    initStarfield();
  }
</script>

<script>
  // GSAP animations for hero content
  import { gsap } from 'gsap';
  
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  
  // Animate hero content on load
  function animateHero() {
    const timeline = gsap.timeline({ defaults: { ease: 'power3.out' } });
    
    if (prefersReducedMotion) {
      // Instant appearance for reduced motion
      gsap.set(['.hero-title', '.hero-subtitle', '.hero-description', '.hero-ctas'], { 
        opacity: 1 
      });
    } else {
      // Animated entrance
      timeline
        .from('.hero-name', {
          duration: 1.2,
          opacity: 0,
          y: 50,
          scale: 0.9,
        })
        .from('.hero-subtitle', {
          duration: 0.8,
          opacity: 0,
          y: 30,
        }, '-=0.4')
        .to('.hero-description', {
          duration: 0.8,
          opacity: 1,
          y: 0,
        }, '-=0.2')
        .to('.hero-ctas', {
          duration: 0.8,
          opacity: 1,
          y: 0,
        }, '-=0.4');
    }
  }
  
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', animateHero);
  } else {
    animateHero();
  }
</script>

<style>
  .starfield-hero {
    background: radial-gradient(
      ellipse at center,
      oklch(0.18 0.04 240) 0%,
      oklch(0.10 0.01 240) 100%
    );
  }
  
  .hero-name {
    background: linear-gradient(
      135deg,
      oklch(0.85 0.15 240) 0%,
      oklch(0.75 0.20 270) 50%,
      oklch(0.65 0.25 240) 100%
    );
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 0 40px rgba(100, 150, 255, 0.3);
  }
  
  .hero-content {
    animation: fadeIn 0.5s ease-out;
  }
  
  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }
  
  /* Reduced motion fallback */
  @media (prefers-reduced-motion: reduce) {
    .hero-name {
      text-shadow: 0 0 20px rgba(100, 150, 255, 0.5);
    }
    
    .scroll-arrow {
      animation: none;
    }
    
    * {
      animation-duration: 0.01ms !important;
      transition-duration: 0.01ms !important;
    }
  }
</style>
